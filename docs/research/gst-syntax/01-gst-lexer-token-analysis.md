# GNU Smalltalk Lexer: Token Inventory and Recognition

This section details the syntax of GNU Smalltalk as inferred from its lexer (`lex.c`, `lex.h`) and parser (`gst-parse.c`, `gst-parse.h`) source code (version 3.2.5), focusing on tokenization.

## A. Token Inventory (from `gst-parse.h` and `lex.c`)

The primary tokens are defined in `gst-parse.h` via the `TOKEN_DEFS` macro and the `enum yytokentype`. Single-character tokens are often returned directly by their ASCII value.

**Defined Token Types (from `gst-parse.h`):**

*   `SCOPE_SEPARATOR` (261): `::` (Generated by `scan_colon()` in `lex.c`. A single `.` is returned as its ASCII value.)
*   `ASSIGNMENT` (262): `_` or `:=`
*   `SHEBANG` (263): `#!` (at the beginning of a file)
*   `IDENTIFIER` (264): General identifiers
*   `BINOP` (265): Binary operators (multi-character, or single like `%`, `&`, `*`, `+`, etc.)
*   `KEYWORD` (266): Identifiers ending with a colon (e.g., `aKeyword:`)
*   `STRING_LITERAL` (267): e.g., `'a string'`
*   `SYMBOL_LITERAL` (268): e.g., `#aSymbol`, `#'a string'`, `#+`
*   `INTEGER_LITERAL` (269): e.g., `123`, `16rFF`
*   `LARGE_INTEGER_LITERAL` (270): Integers exceeding small integer range
*   `BYTE_LITERAL` (271): (Comment in `gst-parse.h` says "small integer literal". However, `lex.c` does not produce this token for elements within byte arrays. Elements of byte arrays are lexed as `INTEGER_LITERAL`. `BYTE_LITERAL` may be an internal parser token or a vestige not directly relevant for TextMate grammar based on lexer output for byte array contents.)
*   `FLOATD_LITERAL` (272): Double-precision floats (e.g., `1.0`, `1.0d`)
*   `FLOATE_LITERAL` (273): Single-precision floats (e.g., `1.0e`)
*   `FLOATQ_LITERAL` (274): Quad-precision floats (e.g., `1.0q`)
*   `SCALED_DECIMAL_LITERAL` (275): e.g., `1.2s2`
*   `CHAR_LITERAL` (276): e.g., `$a`, `$<65>`
*   `ERROR_RECOVERY` (277): Special token for parser error recovery, often related to newlines.

**Single Character Tokens (returned by ASCII value from `lex.c` via `char_table` or specific functions):**

*   `.` (period): Statement separator.
*   `^` (caret): Return statement
*   `;` (semicolon): Cascade separator
*   `:` (colon): Part of `ASSIGNMENT` (`:=`), `KEYWORD`, or `SCOPE_SEPARATOR` (`::`), or returned as itself if not forming one of these.
*   `|` (pipe): Part of `BINOP`, temporary variable delimiter, or block argument separator.
*   `(` `)`: Expression grouping, array literals.
*   `[` `]`: Block delimiters, byte array literals.
*   `{` `}`: Array constructor, binding constants.
*   `#`: Start of symbol, array literal, byte array literal, binding constant, or compile-time constant.
*   `_`: `ASSIGNMENT` token.
*   `!` (bang): File-out chunk separator.
*   `<` `>` `-`: Can be `BINOP` or returned as themselves.

## B. Token Recognition Details (from `lex.c`)

The lexer (`lex.c`) uses a dispatch table (`char_table`) based on the initial character and specific scanning functions.

*   **Literals:**
    *   **String Literals (`STRING_LITERAL`):** Scanned by `string_literal()`. Enclosed in single quotes (`'...'`). A doubled single quote (`''`) represents a literal single quote.
    *   **Character Literals (`CHAR_LITERAL`):** Scanned by `char_literal()`. Starts with `$` followed by a character (e.g., `$a`, `$$`). Also supports Unicode code points like `$<65>`.
    *   **Number Literals:** Scanned by `scan_number()`.
        *   **Integers (`INTEGER_LITERAL`, `LARGE_INTEGER_LITERAL`):** Sequence of digits. Can have a radix prefix (e.g., `2r101`, `16rFF`). Underscores (`_`) are allowed as separators (e.g., `1_000_000`).
        *   **Floats (`FLOATD_LITERAL`, `FLOATE_LITERAL`, `FLOATQ_LITERAL`):** Integers with a decimal part (`.`) and/or an exponent (`e`, `d`, `q`). Radix can apply.
        *   **Scaled Decimals (`SCALED_DECIMAL_LITERAL`):** Numbers followed by `s` and an optional scale factor (e.g., `1.2s`, `1.2s2`). Radix can apply.
    *   **Symbol Literals (`SYMBOL_LITERAL`):** Scanned by `scan_symbol()`.
        *   Starts with `#`.
        *   Can be an identifier: `#aSymbol`, `#anotherKeyword:`.
        *   Can be a quoted string: `#'a string with spaces'`
        *   Can be a binary operator: `#+`, `#<=`.
    *   **Array Literals:** Recognized by the parser. Syntax: `#(` followed by space-separated literals (numbers, symbols, strings, characters, other literal arrays, nil/true/false) and closed by `)`. Example: `#(1 'two' $3 #four)`. The `#` and `(` are distinct tokens for the parser.
    *   **Byte Array Literals:** Recognized by the parser. Syntax: `#[` followed by space-separated small integers (0-255, lexed as `INTEGER_LITERAL`) and closed by `]`. Example: `#[255 0 128]`. The `#` and `[` are distinct tokens.

*   **Identifiers & Keywords:**
    *   **Identifiers (`IDENTIFIER`):** Scanned by `scan_ident()`. Start with a letter, followed by letters or digits. The `scan_ident()` function does not appear to incorporate `$` into general identifiers; its use seems limited to character literals or specific constructs.
    *   **Keywords (`KEYWORD`):** Also scanned by `scan_ident()`. An identifier immediately followed by a colon (`:`) that is not part of `:=` or `::` is tokenized as `KEYWORD`. Example: `ifTrue:`, `aKeyword:`.
    *   **Reserved Words/Pseudo-variables:** `true`, `false`, `nil`, `self`, `super`, `thisContext`. These are parsed as `IDENTIFIER` tokens by the lexer; the parser (`gst-parse.c`, e.g., in `parse_builtin_identifier` or `is_unlikely_selector`) gives them special meaning based on their string value.

*   **Operators:**
    *   **Assignment (`ASSIGNMENT`):** `:=` (from `scan_colon()`) or `_` (directly from `char_table`).
    *   **Binary Operators (`BINOP`):** Scanned by `scan_bin_op()`. Typically one or two characters from the set: `% & * + , - / < = > ? @ \ | ~`.
        *   Single characters like `<`, `>`, `-`, `|` can be returned as their own char value if they don't form a longer `BINOP` or other special token.
    *   **Scope Separator (`SCOPE_SEPARATOR`):** `::` (from `scan_colon()`).
    *   **Unary Selectors:** Are `IDENTIFIER` tokens.
    *   **Keyword Selectors:** Are `KEYWORD` tokens.

*   **Comments:**
    *   Scanned by `comment()`. Enclosed in double quotes (`"..."`). They can span multiple lines. Nested comments are not standard.

*   **Punctuation & Delimiters:**
    *   `.` (Period): Statement terminator. `lex.c` returns the char. `scan_newline()` can also effectively insert a period in REPL mode if `parenthesis_depth` is zero.
    *   `^` (Caret): Return. `lex.c` returns the char.
    *   `;` (Semicolon): Cascade message separator. `lex.c` returns the char.
    *   `(` `)`: Expression grouping, array literal delimiters. `lex.c` returns the chars.
    *   `[` `]`: Block delimiters, byte array delimiters. `lex.c` returns the chars.
    *   `{` `}`: Array constructor delimiters, binding constant delimiters. `lex.c` returns the chars.
    *   `|` (Pipe): Delimits temporaries in methods/blocks, or arguments in blocks if not preceded by `:arg`. Can also be a `BINOP`. `lex.c` returns the char or `BINOP`.
    *   `!` (Bang): File-out chunk separator. `lex.c` returns the char.

*   **Character Classes/Properties (from `char_table` in `lex.c`):**
    *   `WHITE_SPACE`: Space, tab, CR, LF (newline is handled specially by `scan_newline`).
    *   `DIGIT`: `0-9`.
    *   `ID_CHAR`: Letters, digits, `_`. (Note: `char_table` also lists `$` and `:` as `ID_CHAR`, but `scan_ident` logic appears more restrictive for general identifiers. `$` is primarily for char literals, and `:` for keywords/special operators).
    *   `BIN_OP_CHAR`: `% & * + , - / < = > ? @ \ | ~`.
    *   `SYMBOL_CHAR`: Letters, digits, `_`. (Effectively `ID_CHAR` for symbol construction, with `scan_symbol` handling colons for keyword symbols).
